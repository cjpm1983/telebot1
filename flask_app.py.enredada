from flask import Flask, request
import os
import logging
import telegram
<<<<<<< HEAD
import logging
from telegram.ext import Updater, CallbackQueryHandler, CallbackContext

=======
import time
from telegram import Update
from telegram.ext import CallbackContext, CommandHandler, Updater

#locales
>>>>>>> a98faf402432e301ad5c49d769e913d6896449b5
from telebot.credentials import bot_token, bot_user_name,URL
from telebot.mastermind import get_response
#global bot
global TOKEN
TOKEN = bot_token
<<<<<<< HEAD
bot = telegram.Bot(token=TOKEN)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')
logger = logging.getLogger("test")

#from telegram.ext import (Updater, CommandHandler)

app = Flask(__name__)

#@app.route('/')
#def hello_world():
#    return 'Hello from Flask!'

@app.route('/{}'.format(TOKEN), methods=['POST'])
def respond():
    #updatet = telegram.Update
    #query = updatet.callback_query

    # CallbackQueries need to be answered, even if no notification to the user is needed
    # Some clients may have trouble otherwise. See https://core.telegram.org/bots/api#callbackquery
    #query.answer()
    #updater = Updater(TOKEN)

    #updater.dispatcher.add_handler(CallbackQueryHandler(button))
    
    # retrieve the message in JSON and then transform it to Telegram object
    update = telegram.Update.de_json(request.get_json(force=True), bot)
    logger.info(f"update id is : {update}")
    chat_id=-1
    msg_id=-1
    text = ""
    bundle = {}
    if (update.callback_query):
        chat_id = update.callback_query.message.chat.id
        msg_id = update.callback_query.message.message_id
        text = update.callback_query.data.encode('utf-8').decode()
        
    else:
       chat_id = update.message.chat.id
       msg_id = update.message.message_id
       text = update.message.text.encode('utf-8').decode()

    bundle = get_response(text)
    print("got text message :", text)
# here we call our super AI
    '''
    markup = {'inline_keyboard': [[{'text': 'Gn', 'callback_data': 'Return value 1'},
             {'text': 'Mt', 'callback_data': 'Return value 2'}]]}
    if text == '/start':
        bot.sendMessage (chat_id=chat_id, text=str("Hi! Which one do you want? choose from the below keyboard buttons."), reply_markup=markup)
        bot.sendMessage(chat_id=chat_id, text=str(now.hour)+str(":")+str(now.minute))
        return 'ok'
    '''
    #logger.info(f"update id is : {update}")

    #bundle = get_response(text)
# now just send the message back
    # notice how we specify the chat and the msg we reply to
    #bot.sendMessage(chat_id=chat_id, text=response, reply_to_message_id=msg_id)
    response = bundle["txt"]
    if len(response) > 4096:
       for x in range(0, len(response), 4096):
          bot.send_message(chat_id=chat_id, text=response[x:x+4096])
    else:
       bot.send_message(chat_id=chat_id, text=response)

    if "btns" in bundle.keys():
       btns = bundle["btns"]
       bot.sendMessage (chat_id=chat_id, text=str("------------------"), reply_markup=btns)
    
    return 'ok'


def button(update: telegram.Update, context: CallbackContext) -> None:
    """Parses the CallbackQuery and updates the message text."""
    query = update.callback_query

    # CallbackQueries need to be answered, even if no notification to the user is needed
    # Some clients may have trouble otherwise. See https://core.telegram.org/bots/api#callbackquery
    query.answer()

    query.edit_message_text(text=f"Selected option: {query.data}")
=======
#bot = telegram.Bot(token=TOKEN)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')
logger = logging.getLogger("test")
#herokuname = "name"
#PORT = int(os.environ.get('PORT', '8443'))
updater = Updater(TOKEN, use_context=True)
bot = updater.bot
update_queue = updater.update_queue
dispatcher = updater.dispatcher

app = Flask(__name__)

@app.route('/' + TOKEN, methods=['POST'])
def webhook():
    update = telegram.update.Update.de_json(request.get_json(force=True), bot)
    logger.info(f"update id is : {update.update_id}")
    update_queue.put(update)
    return 'OK'


def start(update:Update, context:CallbackContext):
    msg_id = update.message.message_id
    update.message.reply_text("ok")
>>>>>>> a98faf402432e301ad5c49d769e913d6896449b5


#eSTE ultimo ejemplo no incluye esta funcionsino que llama setwebhook 
#en elmain, lodejamos pues no debe de dar conflicto
@app.route('/setwebhook', methods=['GET', 'POST'])
def set_webhook():
    # we use the bot object to link the bot to our app which live
    # in the link provided by URL
    s = bot.setWebhook('{URL}{HOOK}'.format(URL=URL, HOOK=TOKEN))
    # something to let us know things work
    if s:
        return "webhook setup ok"
    else:
        return "webhook setup failed"



@app.route('/')
def index():
    return '.'


if __name__ == '__main__':
    dispatcher.add_handler(CommandHandler("start", start))
    updater._init_thread(dispatcher.start, "dispatcher")
    
    #teniamos bot.setWebhook pero cambiamos a set_webhook porque los bot se 
    #declaran diferente en este ejemplo, aqui es a partir del updater en el otro es de telegram
    bot.setWebhook('{URL}{HOOK}'.format(URL=URL, HOOK=TOKEN))
    #bot.set_webhook(f"https://{herokuname}.herokuapp.com/{TOKEN}")

    time.sleep(5)
    # note the threaded arg which allow
    # your app to have more than one thread
    app.run(threaded=True)
    
